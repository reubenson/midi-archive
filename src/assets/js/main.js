'use-strict'
const Timidity = require('timidity')
let player
let currentlyPlaying = null
let midiFiles = []
const pathPrefix = '/midi-archive/'
const REVERB_FILE = 'https://reubenson.com/weaving/Swede%20Plate%203.0s.wav'

class MidiPlayer {
  constructor () {
    this.player = new Timidity(pathPrefix + 'assets/timidity')
    this.addReverbNode()

    this.player.on('playing', () => {
      this.duration = this.player.duration
    })

    this.player.on('error', (err) => {
      console.error(err)
    })

    this.player.on('ended', () => {
      this.playerStatus = 'finished playing'
      this.setStatus()
      this.playButton.classList.toggle('hidden', false)
      this.pauseButton.classList.toggle('hidden', true)
    })

    this.playButton = document.querySelector('.play-button')
    this.playButton?.addEventListener('click', this.play.bind(this))
    this.pauseButton = document.querySelector('.stop-button')
    this.pauseButton?.addEventListener('click', this.pause.bind(this))
    this.randomButton = document.querySelector('.random-button')
    this.randomButton?.addEventListener('click', this.playRandom.bind(this))
    this.statusEl = document.querySelector('.status')
    // default player to model prediction
    this.url = 'https://midi-archive.s3.us-east-2.amazonaws.com/neural-net/model-prediction.mid'
    this.setStatus('Click <em>Play</em> to listen to MIDI generated by the neural net model, or click <em>Random to listen to a random song from the archive</em>!')
    this.duration = null
    this.load(this.url)
  }

  async addReverbNode () {
    const ctx = this.player._audioContext
    const reverb = ctx.createConvolver()

    // load impulse response from file
    const response = await fetch(REVERB_FILE)
    const arraybuffer = await response.arrayBuffer()
    reverb.buffer = await ctx.decodeAudioData(arraybuffer)

    // add reverb to MIDI player
    this.player._node.connect(reverb)
    reverb.connect(ctx.destination)
  }

  getRandomSongUrl () {
    if (!midiFiles.length) {
      midiFiles = document.getElementsByClassName('midi-archive-collection-item')
    }

    const index = Math.round(Math.random() * midiFiles.length)
    const fileEl = midiFiles[index]

    // should move this elsewhere, not in scope for getting a url
    fileEl.classList.toggle('playing')
    updateCurrentlyPlaying(fileEl)
    fileEl.scrollIntoView({ behavior: 'smooth' })
    // need to wait for previous scroll action to finish
    // const container = document.querySelector('.container')
    // container?.scrollBy({ behavior: 'smooth', top: 60 })

    return fileEl.getAttribute('data-src')
  }

  playRandom () {
    const url = this.getRandomSongUrl()

    this.playFromArchive(url)
  }

  playFromArchive (url) {
    this.url = url
    this.load(url)
    this.play()
  }

  load (url) {
    try {
      this.player.load(url)
    } catch (error) {
      console.error(error)
      this.setStatus('There was an error playing this file!')
    }
  }

  play () {
    this.player.play()
    this.playButton.classList.toggle('hidden', true)
    this.pauseButton.classList.toggle('hidden', false)
    this.playerStatus = 'playing'
    this.setStatus()
  }

  pause () {
    this.player.pause()
    this.pauseButton.classList.toggle('hidden')
    this.playButton.classList.toggle('hidden')
    this.playerStatus = 'paused'
    this.setStatus()
  }

  setStatus (str = '') {
    const filename = this.url.split('/').pop()
    this.statusEl.innerHTML = str || `${this.playerStatus} <strong>${filename}</strong>`
  }
}

// add hover functionality to midi files
window.onload = function () {
  player = new MidiPlayer()
}

document.addEventListener('click', clickHandler)

function clickHandler (event) {
  const isMidiItem = event.target.classList.contains('midi-archive-collection-item')

  console.log('event', event)

  // may want to create some overlap between elements so that user cannot click in between two surface elements
  if (isMidiItem) {
    const url = event.target.getAttribute('data-src')
    player.playFromArchive(url)
    updateCurrentlyPlaying(event.target)
  }
}

function updateCurrentlyPlaying (item) {
  // add class to visually signify that the file is playing
  if (currentlyPlaying) {
    currentlyPlaying.classList.toggle('playing', false) // turn off previous
  }
  item.classList.toggle('playing', true) // turn on current
  currentlyPlaying = item
}
