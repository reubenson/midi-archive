'use-strict'
const Timidity = require('timidity')
let player
let currentlyPlaying = null
let midiFiles = []
const pathPrefix = '/midi-archive/'

class MidiPlayer {
  constructor () {
    this.player = new Timidity(pathPrefix + 'assets/timidity')
    this.player.on('playing', () => {
      console.log('currently playing', currentlyPlaying)
      console.log(player) // => 351.521
      this.duration = player.duration
      console.log('player.duration', player.duration)
    })

    this.player.on('ended', () => {
      this.playerStatus = 'finished playing'
      this.setStatus()
    })

    this.playButton = document.querySelector('.play-button')
    this.playButton?.addEventListener('click', this.play.bind(this))
    this.pauseButton = document.querySelector('.stop-button')
    this.pauseButton?.addEventListener('click', this.pause.bind(this))
    this.randomButton = document.querySelector('.random-button')
    this.randomButton?.addEventListener('click', this.playRandom.bind(this))
    this.statusEl = document.querySelector('.status')
    // default player to model prediction
    this.url = 'https://midi-archive.s3.us-east-2.amazonaws.com/neural-net/model-prediction.mid'
    this.setStatus('Click <em>Play</em> to listen to MIDI generated by the neural net model, or click into any .mid file in the archive!')
    this.duration = null
    this.load(this.url)
  }

  getRandomSongUrl () {
    console.log('midiFiles.length', midiFiles.length);
    if (!midiFiles.length) {
      midiFiles = document.getElementsByClassName('midi-archive-collection-item-surface')
    }

    const index = Math.round(Math.random() * midiFiles.length)
    const fileSurfaceEl = midiFiles[index]
    const fileEl = fileSurfaceEl.parentNode.querySelector('a')

    // should move this elsewhere, not in scope for getting a url
    fileSurfaceEl.parentNode.classList.toggle('playing')
    updateCurrentlyPlaying(fileEl.parentNode)
    fileEl.scrollIntoView({ behavior: 'smooth' })
    // need to wait for previous scroll action to finish
    // const container = document.querySelector('.container')
    // container?.scrollBy({ behavior: 'smooth', top: 60 })

    return fileEl.getAttribute('href')
  }

  playRandom () {
    const url = this.getRandomSongUrl()

    this.playFromArchive(url)
  }

  playFromArchive (url) {
    this.url = url
    this.load(url)
    this.play()
  }

  load (url) {
    this.player.load(url)
  }

  play () {
    this.player.play()
    this.playButton.classList.toggle('hidden', true)
    this.pauseButton.classList.toggle('hidden', false)
    this.playerStatus = 'playing'
    this.setStatus()
  }

  pause () {
    this.player.pause()
    this.pauseButton.classList.toggle('hidden')
    this.playButton.classList.toggle('hidden')
    this.playerStatus = 'paused'
    this.setStatus()
  }

  setStatus (str = '') {
    const filename = this.url.split('/').pop()
    this.statusEl.innerHTML = str || `${this.playerStatus} <strong>${filename}</strong>`
  }
}

// add hover functionality to midi files
window.onload = function () {
  player = new MidiPlayer()
}

document.addEventListener('click', clickHandler)

function clickHandler (event) {
  const targetId = event.target.id
  const isSurface = event.target.classList.contains('midi-archive-collection-item-surface')

  // may want to create some overlap between elements so that user cannot click in between two surface elements
  if (isSurface) {
    const collectionItem = event.target.parentNode

    player.playFromArchive(`/midi-archive/${targetId}`)
    updateCurrentlyPlaying(collectionItem)
  }
}

function updateCurrentlyPlaying (item) {
  // add class to visually signify that the file is playing
  if (currentlyPlaying) {
    currentlyPlaying.classList.toggle('playing', false) // turn off previous
  }
  item.classList.toggle('playing', true) // turn on current
  currentlyPlaying = item
}
