'use-strict'
const Timidity = require('timidity')
let player
let currentlyPlaying = null
let midiFiles = []
const pathPrefix = '/midi-archive/'
const AI_FILEPATH = 'https://midi-archive.s3.us-east-2.amazonaws.com/neural-net/model-prediction.mid'
const REVERB_FILE = 'https://reubenson.com/weaving/Swede%20Plate%202.0s.wav'

class MidiPlayer {
  constructor () {
    this.player = new Timidity(pathPrefix + 'assets/timidity')
    this.addReverbNode()
    this.playButton = document.querySelector('.play-button')
    this.playButton?.addEventListener('click', this.play.bind(this))
    this.pauseButton = document.querySelector('.stop-button')
    this.pauseButton?.addEventListener('click', this.pause.bind(this))
    this.randomButton = document.querySelector('.random-button')
    this.randomButton?.addEventListener('click', this.playRandom.bind(this))
    this.aiButton = document.querySelector('.ai-button')
    this.aiButton?.addEventListener('click', this.playAI.bind(this))
    this.statusEl = document.querySelector('.status')
    this.shareLink = document.querySelector('.share')
    // default player to model prediction
    this.url = AI_FILEPATH
    // this.setStatus('Click <em>Play</em> to listen to MIDI generated by the neural net model, or click <em>Random to listen to a random song from the archive</em>!')
    this.duration = null
    this.selectedFilename = ''
    this.hash = ''
    // this.needsFirstScroll = false
    this.load(this.url)
    this.checkShared()
    this.displayIntro()

    this.player.on('playing', () => {
      this.duration = this.player.duration
      this.playerStatus = 'playing'
      this.setStatus()
    })

    this.player.on('error', (err) => {
      console.error(err)
      this.playerStatus = 'error playing'
      this.setStatus()
    })

    this.player.on('ended', () => {
      this.playerStatus = 'finished playing'
      this.setStatus()
      this.playButton.classList.toggle('hidden', false)
      this.pauseButton.classList.toggle('hidden', true)
    })
  }

  displayIntro () {
    if (this.selectedFilename && this.selectedFilename !== 'model-prediction.mid') {
      this.setStatus(`Click <em>Play</em> to listen to ${this.selectedFilename} or click around!`)
    } else {
      this.setStatus('Click <em>Play</em> to listen to music generated by the AI model or click around!')
    }
  }

  checkShared () {
    const hash = document.location.hash

    if (hash) {
      this.selectedFilename = hash?.split('/').pop()
      this.hash = hash.replace('#', '')
      this.selectedEl = document.getElementById(this.hash)
      this.url = this.selectedEl?.getAttribute('data-src')
      this.load(this.url)
      // this.needsFirstScroll = true
    }
  }

  async addReverbNode () {
    const ctx = this.player._audioContext
    const reverb = ctx.createConvolver()

    // load impulse response from file
    const response = await fetch(REVERB_FILE)
    const arraybuffer = await response.arrayBuffer()
    reverb.buffer = await ctx.decodeAudioData(arraybuffer)

    // add reverb to MIDI player
    this.player._node.connect(reverb)
    reverb.connect(ctx.destination)
  }

  getRandomSongUrl () {
    if (!midiFiles.length) {
      midiFiles = document.getElementsByClassName('midi-archive-collection-item')
    }

    const index = Math.round(Math.random() * midiFiles.length)
    const fileEl = midiFiles[index]

    // should move this elsewhere, not in scope for getting a url
    fileEl.classList.toggle('playing')
    updateCurrentlyPlaying(fileEl)
    fileEl.scrollIntoView({ behavior: 'smooth' })
    // need to wait for previous scroll action to finish
    // const container = document.querySelector('.container')
    // container?.scrollBy({ behavior: 'smooth', top: 60 })

    return fileEl.getAttribute('data-src')
  }

  displaySelectedSong () {
    const el = this.selectedEl

    el.classList.toggle('playing')
    updateCurrentlyPlaying(el)
    el.scrollIntoView({ behavior: 'smooth' })
  }

  // playFileById (id) {
  //   const fileEl = document.getElementById(id)
  //   const src = fileEl.getAttribute('data-src')

  //   fileEl.classList.toggle('playing')
  //   updateCurrentlyPlaying(fileEl)
  //   fileEl.scrollIntoView({ behavior: 'smooth' })

  //   // this.playFromArchive(src)
  // }

  playRandom () {
    const url = this.getRandomSongUrl()

    this.playFromArchive(url)
  }

  playFromArchive (url) {
    this.url = url
    this.load(url)
    this.play()
  }

  playAI () {
    this.selectedEl = document.getElementById('neural-net-output')
    // this.url = AI_FILEPATH
    this.playFromArchive(AI_FILEPATH)
    this.displaySelectedSong()
  }

  load (url) {
    try {
      this.player.load(url)
      this.playerStatus = 'loading'
      this.selectedFilename = url.split('/').pop()
      this.setStatus()
    } catch (error) {
      console.log('hitting this')
      console.error(error)
      this.setStatus('There was an error playing this file!')
      this.playerStatus = 'error playing'
      this.setStatus()
    }
  }

  play () {
    // if (this.needsFirstScroll) {
      // this.playFileById(this.hash)
      // this.displaySelectedSong()
    // }
    // } else {
    this.player.play()
    this.playButton.classList.toggle('hidden', true)
    this.pauseButton.classList.toggle('hidden', false)
    this.setStatus()
  }

  pause () {
    this.player.pause()
    this.pauseButton.classList.toggle('hidden')
    this.playButton.classList.toggle('hidden')
    this.playerStatus = 'paused'
    this.setStatus()
  }

  setStatus (str = '') {
    this.statusEl.innerHTML = str || `${this.playerStatus} <strong>${this.selectedFilename}</strong>`
    this.shareLink.innerText = 'Link to share this song'

    if (this.url) {
      const hash = this.url.split(pathPrefix)[1]

      if (hash) {
        this.shareLink.setAttribute('href', `#/${hash}`)
      } else {
        this.shareLink.setAttribute('href', '#neural-net-output')
      }
    }
  }
}

// add hover functionality to midi files
window.onload = function () {
  player = new MidiPlayer()
}

document.addEventListener('click', clickHandler)

function clickHandler (event) {
  const isMidiItem = event.target.classList.contains('midi-archive-collection-item')

  console.log('event', event)

  // may want to create some overlap between elements so that user cannot click in between two surface elements
  if (isMidiItem) {
    const url = event.target.getAttribute('data-src')
    player.playFromArchive(url)
    updateCurrentlyPlaying(event.target)
  }
}

function updateCurrentlyPlaying (item) {
  // add class to visually signify that the file is playing
  if (currentlyPlaying) {
    currentlyPlaying.classList.toggle('playing', false) // turn off previous
  }
  item.classList.toggle('playing', true) // turn on current
  currentlyPlaying = item
}
